---
title: "Ralph Loop: 완료 조건만 주면 알아서 반복하는 Claude Code 플러그인"
date: 2026-01-17 21:00:00 +0900
categories: [AI, Claude Code]
tags: [claude-code, ralph-loop, ai-automation, tdd]
---

## 발견

Claude Code를 쓰다 보면 답답할 때가 있습니다. 분명 "테스트 통과할 때까지 고쳐"라고 했는데, 한 번 고치고 끝. 다시 명령 내리고, 또 고치고, 또 명령 내리고... 이 반복이 은근 귀찮습니다.

근데 이걸 자동으로 해주는 플러그인이 있었습니다. **Ralph Loop**이라는 건데, 이름이 심슨 캐릭터 랄프 위검(Ralph Wiggum)에서 따왔다고 합니다. 실수를 해도 끈기 있게 계속 시도하는 캐릭터처럼, 목표 달성할 때까지 무식하게 반복한다는 의미입니다.

## 핵심 철학

이 플러그인의 철학은 **"Iteration > Perfection"**입니다. 한 번에 완벽한 코드를 짜는 게 아니라, 실패하면 고치고 다시 시도하는 걸 수십 번 반복하면 결과물이 완벽에 가까워진다는 개념입니다.

또 하나 재밌는 건 **"Failures Are Data"**라는 관점입니다. 실패를 나쁜 것으로 보지 않고, 다음 반복에서 개선할 수 있는 정보로 취급합니다.

## 어떻게 동작하나

원리는 단순합니다. 내부적으로는 bash의 `while true` 루프와 비슷하게 동작합니다.

1. 프롬프트를 줍니다
2. Claude가 작업합니다
3. Claude가 종료를 시도합니다
4. **Stop hook**이 종료를 차단합니다
5. 같은 프롬프트를 다시 주입합니다
6. 완료 조건이 충족될 때까지 반복

핵심은 **Stop hook**입니다. Claude가 "다 했다"고 종료하려고 해도, hook이 이를 가로채서 같은 프롬프트를 다시 넣어줍니다. 그러면 Claude는 이전에 자기가 수정한 파일들과 Git 히스토리를 보면서 작업을 이어갑니다.

## 설치

### 방법 1: 플러그인 마켓플레이스

Claude Code 터미널에서:

```bash
/plugin install ralph-wiggum@claude-plugins-official
```

### 방법 2: 마켓플레이스 검색

```bash
/plugin
# ralph-loop 검색 후 설치
```

### 의존성

JSON 처리를 위해 **jq**가 필요합니다.

```bash
# macOS
brew install jq

# Ubuntu/Debian
apt install jq
```

Windows 사용자는 Git Bash 호환성을 위해 추가 설정이 필요할 수 있습니다.

## 실제로 쓰는 법

기본 형태는 이렇습니다:

```bash
/ralph-loop "<프롬프트>" --max-iterations <횟수> --completion-promise "<완료키워드>"
```

### 옵션 설명

| 옵션 | 설명 |
|------|------|
| `--max-iterations` | 최대 반복 횟수. 무한루프 방지용 안전장치입니다. 꼭 설정하세요. |
| `--completion-promise` | 이 문자열이 출력되면 루프를 멈춥니다. 정확히 일치해야 합니다. |

### 예시: TODO API 만들기

```bash
/ralph-loop "TODO REST API를 만들어줘.
- CRUD 엔드포인트 구현
- 입력 검증 추가
- 테스트 작성하고 실행
- 테스트 실패하면 분석하고 수정

모든 테스트가 통과하면 <promise>COMPLETE</promise> 출력해." \
--completion-promise "COMPLETE" \
--max-iterations 50
```

### 예시: TDD 방식 개발

```bash
/ralph-loop "TDD로 인증 모듈 구현해.
1. 실패하는 테스트 작성
2. 최소 코드로 테스트 통과
3. 리팩토링
4. 다음 테스트로 이동
5. 모든 테스트 통과할 때까지 반복

완료하면 <promise>DONE</promise> 출력해." \
--completion-promise "DONE" \
--max-iterations 30
```

### 루프 취소

무한루프에 빠졌거나 중간에 멈추고 싶으면:

```bash
/cancel-ralph
```

## 프롬프트 작성 팁

### 좋은 프롬프트

명확한 완료 조건과 단계가 있습니다:

```
기능 X를 구현해.

완료 조건:
- 모든 CRUD 엔드포인트 동작
- 입력 검증 적용
- 테스트 통과 (커버리지 80% 이상)
- README에 API 문서 작성

완료하면 <promise>COMPLETE</promise> 출력해
```

### 나쁜 프롬프트

기준이 모호합니다:

```
좋은 API를 만들어줘
최선을 다해서 구현해
```

차이는 **끝나는 조건이 명확한가**입니다. "좋은 코드"는 기준이 없습니다. "테스트 통과"는 기준이 있습니다.

### 탈출 조건 명시

막혔을 때를 대비한 탈출 조건을 넣어두면 좋습니다:

```
15회 반복 후에도 완료 못 하면:
- 현재까지 진행 상황 문서화
- 시도한 접근법 나열
- 막힌 부분 설명
- <promise>BLOCKED</promise> 출력
```

## 주의할 점

**비용을 조심해야 합니다**. 루프 한 번 돌 때마다 API 토큰을 씁니다. 복잡한 작업은 수십 번 반복할 수 있어서 비용이 꽤 나갑니다.

**무한루프를 조심해야 합니다**. AI가 해결 못 하는 문제면 계속 같은 에러만 반복합니다. `--max-iterations`를 꼭 설정하고, 가끔 확인해주세요. `--completion-promise`는 정확히 일치해야 동작하기 때문에, 안전장치로는 `--max-iterations`에 의존하는 게 좋습니다.

## 언제 쓰면 좋을까

- 테스트 기반 개발 (TDD)
- 반복적인 버그 수정
- 리팩토링하면서 테스트 깨지는 거 계속 고칠 때
- **단순 반복 작업** (파일 포맷 변환, 데이터 정리 등)
- **매뉴얼이 확실한 작업** (문서화, 코드 스타일 통일, 마이그레이션)
- 자동 검증이 가능한 작업 (테스트, 린터 등)

결국 "이렇게 하면 된다"가 명확한 작업들입니다. 정해진 규칙대로 100개 파일을 수정하는 건 사람이 하면 지치지만, 이건 지치지 않습니다.

반대로 창의적인 설계나 "이게 맞나?" 하고 사람이 판단해야 하는 건 안 맞습니다. 완료 조건을 코드로 검증할 수 없으면 루프가 언제 끝나야 할지 모르기 때문입니다.

## 실제 사례

- Y Combinator 해커톤에서 하룻밤 사이에 6개 저장소를 생성한 사례가 있습니다.
- $50,000 규모의 프로젝트를 $297의 API 비용으로 완료한 사례도 있습니다.
- 한 개발자는 블로그 마이그레이션 작업에 약 $10 정도의 비용이 들었다고 합니다.

비용 대비 효과는 작업의 성격에 따라 다르지만, 명확하게 정의된 작업에서는 꽤 효율적입니다.

## 마무리

써보니까 핵심은 **검증 가능한 완료 조건**이었습니다. 테스트 통과, 빌드 성공, 린트 에러 0개처럼 예/아니오로 판단되는 게 있어야 합니다.

한 번에 완벽한 결과를 기대하기보다, 시스템으로 퀄리티를 맞춰간다는 개념이 괜찮은 것 같습니다. 다만 비용은 좀 신경 써야 할 듯합니다.

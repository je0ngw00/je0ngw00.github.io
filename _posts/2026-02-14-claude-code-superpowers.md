---
title: "Superpowers: Claude Code에 개발 프로세스를 심는 플러그인"
date: 2026-02-14 18:00:00 +0900
categories: [AI, Claude Code]
tags: [claude-code, superpowers, plugin, tdd, ai-workflow]
---

## Claude Code의 기본 습관

Claude Code에게 "로그인 기능 만들어줘"라고 하면 어떻게 할까요? 대부분 바로 코드부터 짜기 시작합니다. 파일 구조를 훑어보고, 적당한 위치에 코드를 넣고, "다 했습니다"라고 합니다.

문제는 설계가 빠져 있다는 점입니다. JWT를 쓸 건지, 세션을 쓸 건지, 토큰 갱신은 어떻게 할 건지 같은 판단 없이 일단 만들어버립니다. 설계도 없이 건물부터 올리는 느낌이랄까요.

물론 Plan Mode를 켜면 계획을 먼저 세우게 할 수 있습니다. 근데 **계획을 어떻게 세울지**까지 알려주진 않습니다. 이걸 구조적으로 강제하는 플러그인이 있습니다.

## Superpowers란

Jesse Vincent(obra)이 만든 Claude Code 플러그인입니다. [GitHub](https://github.com/obra/superpowers)에서 42,000개 넘는 스타를 받았고, 2026년 1월에 Anthropic 공식 마켓플레이스에도 등록됐습니다.

14개의 "스킬"로 구성된 개발 워크플로우 시스템인데, 핵심 철학이 꽤 뚜렷합니다.

- **TDD 강제**: 테스트 먼저, 코드는 그다음
- **프로세스 > 즉흥**: 구조화된 워크플로우를 따르게 함
- **단순함**: 한 번에 하나씩, 작은 단위로 쪼개서 진행
- **증거 > 주장**: "됩니다"가 아니라 "테스트 통과했습니다"

한마디로 "코드를 잘 짜게" 하는 게 아니라 "개발을 잘 하게" 하는 플러그인입니다.

## 기본 Plan Mode와 뭐가 다른가

Claude Code에는 기본으로 **Plan Mode**가 있습니다. Shift+Tab을 누르면 활성화되고, Claude가 코드 수정 없이 읽기 전용으로 계획을 세웁니다. 플랜 파일에 구현 계획을 작성하고, 사용자가 승인하면 실행에 들어가는 구조입니다.

Plan Mode는 유용하지만, 범위가 제한적입니다. "계획을 세우자"까지만 강제하고, 어떤 형식으로 계획할지, 테스트는 어떻게 할지, 리뷰는 누가 할지에 대해서는 관여하지 않습니다. 자유도가 높다는 건 좋지만, 결국 Claude가 자기 방식대로 계획을 세운다는 뜻이기도 합니다.

Superpowers는 이 Plan Mode를 아예 가로챕니다. v4.3.0부터 `EnterPlanMode`를 intercept해서, Plan Mode에 진입하려고 하면 Superpowers의 brainstorming 스킬이 대신 발동됩니다.

| 항목 | Plan Mode | Superpowers |
|------|-----------|-------------|
| 활성화 | Shift+Tab 수동 | 자동 발동 |
| 범위 | 계획 단계만 | 설계 → 구현 → 테스트 → 리뷰 전체 |
| 설계 강제 | 없음 | Hard Gate (설계 승인 전 코드 금지) |
| TDD | 없음 | RED-GREEN-REFACTOR 강제 |
| 코드 리뷰 | 없음 | 2단계 자동 리뷰 |
| 서브에이전트 | 없음 | 태스크별 서브에이전트 분배 |

Jesse Vincent은 자신의 블로그에서 "Plan Mode는 범용 계획 도구이지, brainstorming이나 design doc을 만드는 방법을 모른다"고 설명합니다.

핵심 차이를 한 줄로 정리하면, **Plan Mode는 도구이고 Superpowers는 방법론**입니다. Plan Mode가 "계획을 세우세요"라면, Superpowers는 "이 순서로 이렇게 계획하세요"입니다.

## 워크플로우 전체 흐름

Superpowers의 워크플로우는 7단계로 이루어집니다. 사용자가 각 단계를 명시적으로 호출하지 않아도, 하나가 끝나면 자동으로 다음 단계로 넘어갑니다.

| 순서 | 스킬 | 역할 |
|------|------|------|
| 1 | brainstorming | 요구사항 탐색, 설계 결정 |
| 2 | using-git-worktrees | 작업 브랜치 격리 |
| 3 | writing-plans | 구현 계획 수립 (2-5분 단위 태스크) |
| 4 | subagent-driven-development | 서브에이전트에 태스크 분배 |
| 5 | test-driven-development | RED-GREEN-REFACTOR 사이클 |
| 6 | requesting-code-review | 2단계 자동 코드 리뷰 |
| 7 | finishing-a-development-branch | 머지/PR/정리 옵션 제시 |

"로그인 기능 만들어줘"라고 하면, brainstorming부터 시작해서 코드 리뷰까지 자동으로 진행됩니다. 각 단계 사이에 사용자 확인(승인)이 들어가기 때문에, 완전 자동은 아니지만 흐름 자체는 플러그인이 잡아줍니다.

이 구조의 핵심은 **되돌아가기가 어렵다**는 점입니다. brainstorming을 건너뛰고 코드부터 짤 수 없고, 테스트 없이 구현을 끝낼 수 없습니다. 각 단계가 다음 단계의 전제 조건이 되기 때문에, 개발자가 "이번 한 번만 대충" 하려고 해도 플러그인이 막습니다.

반대로 말하면, 이 흐름을 한 번 타면 결과물의 품질이 일정 수준 이상으로 나온다는 뜻이기도 합니다.

## 주요 스킬 상세

### brainstorming: 코드 작성 전 설계 강제

가장 먼저 발동되는 스킬이고, Superpowers의 핵심입니다. **Hard Gate**라서 이 단계를 거치지 않으면 코드를 작성할 수 없습니다.

동작 방식이 독특합니다. 한 번에 질문을 하나만 합니다. "무슨 기능이 필요한가요?"부터 시작해서 하나씩 파고들어갑니다. 사용자가 답하면 다음 질문, 또 답하면 다음 질문. 이렇게 요구사항을 꼼꼼히 정리한 뒤에 2-3개의 접근법을 제안합니다.

"그냥 만들어달라고 했는데 질문만 계속 한다"는 느낌이 처음에는 답답할 수 있습니다. 근데 이 과정을 거치고 나면 Claude가 만들어내는 코드의 방향성이 확실히 달라집니다. 뭘 만들지 합의된 상태에서 시작하기 때문입니다.

brainstorming이 끝나면 2-3개의 접근법을 제안하면서 각각의 장단점을 정리해줍니다. 예를 들어 "JWT + Redis 세션 저장 방식", "세션 기반 인증", "OAuth 2.0 위임 방식" 같은 선택지를 보여주고, 사용자가 고르면 그 방향으로 다음 단계(writing-plans)로 넘어갑니다.

### test-driven-development: RED-GREEN-REFACTOR

TDD를 아예 강제합니다. 프로세스는 이렇습니다:

1. **RED**: 실패하는 테스트를 먼저 작성
2. **GREEN**: 테스트를 통과하는 최소한의 코드 작성
3. **REFACTOR**: 통과한 코드를 정리

여기서 극단적인 규칙이 하나 있습니다. **테스트를 작성하기 전에 구현 코드를 먼저 쓰면, 그 코드를 삭제합니다.** "이미 코드가 있으니 테스트만 붙이자"가 안 된다는 뜻입니다. 테스트가 선행되어야 한다는 원칙을 이 정도로 강하게 적용합니다.

또 하나 눈에 띄는 건, 테스트 작성 전에 반드시 기존 테스트를 먼저 실행합니다. 현재 상태가 "GREEN"인지 확인한 다음에 새 테스트를 추가하는 방식입니다. 기존 코드를 깨뜨리지 않겠다는 안전장치입니다.

### systematic-debugging: 4단계 디버깅

버그를 만나면 즉시 고치지 않고, 체계적인 디버깅 프로세스를 따릅니다.

1. **증상 수집**: 에러 메시지, 로그, 재현 조건 정리
2. **가설 수립**: 가능한 원인들을 나열
3. **가설 검증**: 하나씩 테스트하면서 범위를 좁힘
4. **근본 원인 수정**: 증상이 아닌 원인을 고침

특히 **root cause tracing**이 포함되어 있어서, "에러 나는 줄을 고친다"가 아니라 "왜 그 에러가 발생하는지"를 추적합니다. 단순히 `try-catch`를 감싸는 식의 땜빵 수정을 방지하는 구조입니다.

### subagent-driven-development: 서브에이전트 분배

구현 계획이 나오면 태스크를 서브에이전트에게 분배합니다. 메인 에이전트가 직접 코드를 짜는 게 아니라, 각 태스크별로 서브에이전트를 띄워서 병렬로 진행합니다.

핵심은 2단계 리뷰입니다. 서브에이전트가 작업을 마치면:

1. **1단계 리뷰**: 스펙 준수 여부 확인 (요구사항 대로 구현했는가)
2. **2단계 리뷰**: 코드 품질 검토 (설계 원칙, 에러 처리, 일관성)

서브에이전트가 리뷰를 통과하지 못하면 수정 후 다시 제출합니다. 사람이 코드 리뷰하는 과정과 비슷한 구조입니다.

재밌는 건 메인 에이전트가 서브에이전트에게 태스크를 넘길 때, writing-plans에서 만든 상세 계획을 그대로 전달한다는 점입니다. 앞 단계에서 꼼꼼하게 계획을 세운 게 여기서 효과를 발휘합니다. 서브에이전트가 모호한 지시를 받고 헤매는 일이 줄어듭니다.

### writing-plans: 초보자도 따라할 수 있는 계획서

구현 계획을 **2-5분 단위의 태스크**로 분해합니다. 여기서 재밌는 기준이 있는데, "열정적이지만 경험이 없는 주니어 개발자도 따라할 수 있을 정도로 구체적이어야 한다"는 것입니다.

"유저 인증 구현"이 아니라 "1. /api/login 엔드포인트 생성 (POST, email/password 받음) 2. bcrypt로 패스워드 비교 3. JWT 토큰 생성 후 응답"처럼 쪼갭니다. Claude가 실행할 때 모호함이 없어야 하니까 당연한 접근이긴 합니다.

### using-superpowers: 메타 스킬

이름 그대로 "Superpowers를 어떻게 쓸 것인가"를 정의하는 스킬입니다. 대화 시작 시 가장 먼저 로드되며, **1%라도 관련 스킬이 있으면 발동**시킵니다.

재밌는 건 "Red Flags" 테이블입니다. Claude가 스킬을 건너뛰려고 합리화할 때를 대비한 자기 검열 목록입니다.

| Claude의 생각 | 현실 |
|---------------|------|
| "이건 간단한 질문일 뿐" | 질문도 태스크. 스킬 확인 필요 |
| "먼저 코드베이스 탐색 좀..." | 스킬이 탐색 방법을 알려줌 |
| "정보를 좀 모으고 나서..." | 스킬이 정보 수집 방법을 알려줌 |
| "이 스킬은 과하다" | 단순한 것도 복잡해질 수 있음 |

AI가 자기 자신의 합리화를 방지하는 규칙을 갖고 있다는 게 흥미롭습니다.

## 설치 방법

설치는 간단합니다.

```bash
# 마켓플레이스에서 설치
claude /install-plugin superpowers@claude-plugins-official

# 또는 직접 설치
claude mcp add superpowers -- npx @anthropic/superpower
```

설치 후 Claude Code를 재시작하면 적용됩니다. `/help`를 입력했을 때 슬래시 명령어 목록에 superpowers 관련 명령어들이 보이면 정상입니다.

설치 확인은 대화를 시작해보면 바로 알 수 있습니다. "뭔가 만들어줘"라고 하면 코드부터 짜지 않고 brainstorming 질문이 나옵니다.

## 실제 사용 경험

### 첫 대화에서의 충격

설치 후 처음 "API 엔드포인트 하나 추가해줘"라고 했더니, 바로 코드를 짜는 대신 brainstorming이 발동했습니다. "어떤 리소스의 엔드포인트인가요?", "인증이 필요한가요?", "응답 형식은?" 같은 질문이 하나씩 나왔습니다.

Plan Mode를 직접 누르려고 Shift+Tab을 눌렀더니, brainstorming 스킬로 리다이렉트되는 경험도 했습니다. 기존 Plan Mode와 다르게, 질문이 구조화되어 있어서 빠뜨리는 부분 없이 요구사항이 정리됐습니다.

확인해보니 brainstorming이 끝나면 자동으로 writing-plans로 넘어가면서, 방금 정리한 요구사항을 기반으로 구현 계획을 세우기 시작합니다. 이 계획서가 상당히 상세한데, "이 파일의 몇 번째 줄 근처에 이런 코드를 추가" 수준까지 나옵니다.

### TDD 강제의 효과

TDD 스킬이 가장 호불호가 갈릴 것 같습니다. 간단한 유틸 함수 하나 추가하는데도 테스트부터 작성합니다. 처음에는 "이걸 꼭 이렇게까지?"라는 생각이 듭니다.

근데 결과물을 비교해보면 차이가 있습니다. Superpowers 없이 만든 코드는 동작은 하지만 엣지 케이스에서 터지는 경우가 종종 있었습니다. TDD로 만든 코드는 테스트가 이미 엣지 케이스를 커버하고 있어서 안정적이었습니다.

특히 RED 단계에서 "이 테스트가 왜 실패해야 하는지"를 먼저 생각하게 되니까, 구현의 경계 조건을 자연스럽게 고민하게 됩니다. null 입력, 빈 문자열, 경계값 같은 걸 테스트 단계에서 미리 잡아두니까 나중에 버그로 돌아오는 일이 줄었습니다.

### 서브에이전트 리뷰

서브에이전트가 코드를 작성하고, 메인 에이전트가 리뷰하는 과정이 자동으로 돌아갑니다. 리뷰에서 "이 함수의 에러 처리가 누락됐다" 같은 피드백이 나오고, 서브에이전트가 수정해서 다시 제출하는 걸 지켜보면 신기합니다. 물론 그만큼 토큰을 쓰는 건 감안해야 합니다.

한 가지 인상적이었던 건, 리뷰에서 "스펙에는 에러 시 400 응답이라고 했는데, 구현에서는 500을 반환하고 있다"처럼 brainstorming 단계의 합의사항을 기준으로 검증한다는 점입니다. 앞 단계의 결과물이 뒤 단계의 품질 기준이 되는 구조입니다.

### 적합한 상황 vs 안 맞는 상황

| 적합한 상황 | 안 맞는 상황 |
|------------|-------------|
| 새 기능 개발 (충분한 설계 필요) | 한 줄짜리 버그 수정 |
| 모듈 단위 구현 | 설정 파일 수정 |
| 리팩토링 프로젝트 | 급한 핫픽스 |
| 팀 컨벤션이 중요한 프로젝트 | 프로토타이핑/실험 |

프로토타이핑처럼 빠르게 만들고 버리는 작업에는 과합니다. 반대로 프로덕션 코드를 체계적으로 만들어야 할 때는 확실히 효과가 있습니다.

## 주의사항

**토큰 비용이 확실히 늘어납니다.** brainstorming 단계에서 여러 번 질의응답을 하고, writing-plans에서 상세 계획을 세우고, 코드 리뷰까지 2단계로 하니까 한 기능 구현에 쓰는 토큰이 상당합니다. 체감상 플러그인 없을 때 대비 2-3배 정도입니다.

**간단한 작업에도 brainstorming이 발동합니다.** "README에 한 줄 추가해줘" 같은 사소한 작업인데도 brainstorming이 시작됩니다. 1%라도 관련 스킬이 있으면 발동하는 규칙 때문인데, 이게 때로는 과합니다.

**Hard Gate의 강제성이 거슬릴 때가 있습니다.** 설계 승인 없이 코드를 쓸 수 없기 때문에, "그냥 빨리 만들어줘"가 안 됩니다. 좋게 말하면 규율이고, 나쁘게 말하면 유연성이 떨어집니다.

커뮤니티에서도 비슷한 의견이 있습니다. "코드 품질은 확실히 올라가는데, 토큰을 쿠키몬스터처럼 먹는다"는 반응이 대표적입니다. 비용 효율을 중요하게 생각한다면, 모든 작업에 Superpowers를 적용하기보다 프로덕션 코드 작성 시에만 선택적으로 쓰는 게 현실적입니다.

한 가지 팁이 있다면, CLAUDE.md 파일에 프로젝트별 설정을 넣을 수 있습니다. 프로토타이핑용 프로젝트에서는 brainstorming의 깊이를 낮추거나, 특정 스킬을 비활성화하는 식으로 조절이 가능합니다. 기본 설정 그대로 쓰면 모든 작업에 풀 프로세스가 적용되니까, 프로젝트 성격에 맞게 튜닝하는 게 좋습니다.

## 마무리

Plan Mode가 "계획을 세우세요"라면, Superpowers는 "이 순서대로 이렇게 계획하세요"입니다. Claude Code의 능력을 높이는 게 아니라, 개발 프로세스를 구조화하는 접근입니다.

써보면서 느낀 건, 시니어 개발자가 옆에서 워크플로우를 잡아주는 느낌이라는 점입니다. "먼저 요구사항 정리해", "테스트부터 짜", "코드 리뷰 받아" 이런 식으로 단계를 강제하니까, 결과물의 품질이 일정 수준 이상으로 나옵니다.

비용과 속도를 희생하는 대신 프로세스의 품질을 올리는 트레이드오프입니다. 모든 프로젝트에 맞지는 않지만, "이 코드는 오래 유지보수해야 한다"는 판단이 선다면 한 번 써볼 만합니다.

코드 품질이 아니라 프로세스를 개선하는 접근. 이게 Superpowers의 핵심인 것 같습니다.
